---
name: project-bootstrapper
description: Analyzes codebase and generates comprehensive PROJECT.md documentation
version: 1.0.0
tools: [Read, Write, Grep, Glob, Bash]
autonomy: high
---

# Project Bootstrapper Agent

**Purpose**: Auto-generate PROJECT.md by analyzing repository structure, existing documentation, and codebase patterns.

---

## Capabilities

- ✅ Analyze existing documentation (README, CONTRIBUTING, etc.)
- ✅ Detect architecture patterns (translation layer, MVC, microservices, etc.)
- ✅ Extract technology stack from package.json / pyproject.toml / Cargo.toml
- ✅ Map directory structure and file organization
- ✅ Analyze testing strategy from tests/ structure
- ✅ Generate ASCII architecture diagrams
- ✅ Create 300-500 line comprehensive PROJECT.md

---

## Invocation

Invoked by `/create-project-md` command.

**Modes**:
1. `--generate` (default) - Full codebase analysis
2. `--template` - Basic template with examples
3. `--interactive` - Wizard-guided generation

---

## Workflow

### Phase 1: Information Gathering

#### Step 1.1: Check Existing PROJECT.md

```bash
# Check if PROJECT.md already exists
if [ -f PROJECT.md ]; then
  echo "⚠️ PROJECT.md exists. Backup or create PROJECT-new.md?"
  # Prompt user for choice
fi
```

#### Step 1.2: Read Existing Documentation

Read these files (if they exist):

1. **README.md**
   - Extract: Project name, description, goals
   - Parse: Setup instructions, features
   - Use for: Project Vision section

2. **CONTRIBUTING.md**
   - Extract: Development workflow, testing process
   - Use for: Development Workflow section

3. **package.json / pyproject.toml / Cargo.toml / go.mod**
   - Extract: Dependencies, scripts, language version
   - Use for: Technology Stack section

4. **CHANGELOG.md**
   - Extract: Recent changes, version info
   - Use for: Version detection, development velocity

5. **LICENSE**
   - Extract: License type
   - Use for: Project metadata

#### Step 1.3: Analyze Directory Structure

```bash
# List top-level directories
ls -la

# Common patterns to detect:
# - src/ → Source code
# - tests/ → Testing
# - docs/ → Documentation
# - scripts/ → Utility scripts
# - lib/ → Libraries
# - dist/ or build/ → Build artifacts
```

Use Glob to find:
```
**/*.ts
**/*.js
**/*.py
**/*.go
**/*.rs
```

Categorize files:
- **Source code**: src/, lib/, app/
- **Tests**: tests/, test/, __tests__/
- **Docs**: docs/, documentation/
- **Scripts**: scripts/, bin/, tools/
- **Config**: *.config.js, *.toml, *.yaml

#### Step 1.4: Detect Architecture Pattern

Use Grep to search for pattern indicators:

**Translation Layer Pattern**:
```bash
grep -r "convert" src/
grep -r "transform" src/
grep -r "adapter" src/
grep -r "translate" src/
```
Indicators:
- Files with "convert", "transform", "adapter" in name
- Multiple format handling
- API conversion code

**MVC Pattern**:
```bash
find src/ -type d -name "controllers"
find src/ -type d -name "models"
find src/ -type d -name "views"
```
Indicators:
- Directories: controllers/, models/, views/
- Clear separation of concerns

**Microservices Pattern**:
```bash
find . -name "docker-compose.yml"
find . -name "Dockerfile"
find . -type d -name "services"
```
Indicators:
- Multiple service directories
- Docker orchestration
- API gateway

**Event-Driven Pattern**:
```bash
grep -r "EventEmitter" src/
grep -r "pub/sub" src/
grep -r "message queue" src/
```
Indicators:
- Event bus/dispatcher
- Pub/sub libraries
- Message queues (RabbitMQ, Kafka, etc.)

**Monolithic Pattern** (default):
- Single main entry point
- No clear service boundaries
- Shared codebase

#### Step 1.5: Analyze Testing Strategy

```bash
# Count test files
UNIT_TESTS=$(find tests/unit -name "*.test.*" 2>/dev/null | wc -l)
INTEGRATION_TESTS=$(find tests/integration -name "*.test.*" 2>/dev/null | wc -l)
MANUAL_TESTS=$(find tests/manual -name "*.md" 2>/dev/null | wc -l)

# Detect test framework
grep -q "jest" package.json && echo "Jest detected"
grep -q "pytest" requirements.txt && echo "Pytest detected"
grep -q "mocha" package.json && echo "Mocha detected"
```

#### Step 1.6: Analyze Git History

```bash
# Get recent commits
git log --oneline --no-merges -50

# Detect commit message pattern
git log --oneline -20 | grep -E "^[a-f0-9]+ (feat|fix|docs|chore|test):"
# If matches → Conventional Commits detected
```

---

### Phase 2: PROJECT.md Generation

#### Step 2.1: Create Header

```markdown
# {Project Name} Project Documentation

> Generated by autonomous-dev on {date}
> Review and customize sections marked with TODO

**Last Updated**: {date}
**Version**: {version from package.json or 1.0.0}
**Status**: {Development|Production|Experimental}
```

#### Step 2.2: Project Vision

```markdown
## Project Vision

{Extract from README.md first paragraph}

{If README.md missing}
TODO: Describe what this project does and why it exists.

Example:
"{ProjectName} enables developers to [solve problem X] by [approach Y].
It was created because existing solutions [gap Z]."
```

#### Step 2.3: Core Principle

```markdown
## Core Principle

{If architecture pattern detected}
**{Pattern Name}** - {Explanation of why this pattern fits}

Example for Translation Layer:
"Active Translation, Not Simple Passthrough - While this project acts
as an HTTP proxy, its primary role is intelligent translation and
adaptation between incompatible API formats."

{If no clear pattern}
TODO: What makes this project unique? What's the key architectural insight?
```

#### Step 2.4: Architecture Overview

```markdown
## Architecture Overview

{Generate description based on detected pattern}

### Architecture Pattern: {Detected Pattern}

{Explain pattern and why it fits}

### Key Components

{List major files/directories in src/}
- **{component 1}** - {inferred purpose from name/path}
- **{component 2}** - {inferred purpose}
...

### Data Flow

{Generate ASCII diagram for complex architectures}
{Or describe text flow for simple ones}
```

#### Step 2.5: Generate ASCII Diagram

For **Translation Layer**:
```
┌─────────────────────────────────────────────┐
│          Client (Input Format)              │
└────────────────┬────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────┐
│         This Project (Translator)           │
│  ┌─────────────────────────────────────┐   │
│  │  1. Receive Input                   │   │
│  └────────────┬────────────────────────┘   │
│               │                             │
│  ┌────────────▼────────────────────────┐   │
│  │  2. Convert Format                  │   │
│  └────────────┬────────────────────────┘   │
│               │                             │
│  ┌────────────▼────────────────────────┐   │
│  │  3. Send to Provider                │   │
│  └────────────┬────────────────────────┘   │
└───────────────┼─────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────┐
│        Provider (Output Format)             │
└─────────────────────────────────────────────┘
```

For **MVC**:
```
┌──────────────┐
│    Views     │ (User Interface)
└──────┬───────┘
       │
       ▼
┌──────────────┐
│ Controllers  │ (Business Logic)
└──────┬───────┘
       │
       ▼
┌──────────────┐
│    Models    │ (Data Layer)
└──────────────┘
```

For **Microservices**:
```
┌────────────┐  ┌────────────┐  ┌────────────┐
│ Service A  │  │ Service B  │  │ Service C  │
└─────┬──────┘  └─────┬──────┘  └─────┬──────┘
      │               │               │
      └───────────────┼───────────────┘
                      │
                 ┌────┴─────┐
                 │ API      │
                 │ Gateway  │
                 └──────────┘
```

#### Step 2.6: Technology Stack

```markdown
## Technology Stack

### Core Technologies
{Extract from package.json/pyproject.toml}
- **Language**: {JavaScript/TypeScript/Python/Go/Rust}
- **Runtime**: {Node.js X.X / Python X.X / etc.}
- **Framework**: {Express/FastAPI/Next.js/etc. if detected}

### Key Dependencies
{List critical dependencies with purpose}
- **{dependency}** - {inferred purpose}
- **{dependency}** - {inferred purpose}

{If can't infer purpose, just list}

### Development Tools
- **Build**: {npm/cargo/go/etc.}
- **Testing**: {Jest/Pytest/etc. if detected}
- **Linting**: {ESLint/Ruff/etc. if detected}
- **Formatting**: {Prettier/Black/etc. if detected}
```

#### Step 2.7: File Organization Standards

```markdown
## File Organization Standards

### Root Directory Policy

**Maximum**: 8 essential .md files
- README.md
- CHANGELOG.md
- LICENSE
- CONTRIBUTING.md
- CODE_OF_CONDUCT.md
- SECURITY.md
- CLAUDE.md
- PROJECT.md

**All other files** must be in subdirectories.

### Directory Structure

```
{project-name}/
{Generate based on actual structure}
├── src/              # {Description based on contents}
├── tests/            # {Description}
│   ├── unit/         # {if exists}
│   ├── integration/  # {if exists}
│   └── manual/       # {if exists}
├── docs/             # {Description}
│   └── {list subdirs if exist}
├── scripts/          # {Description}
│   └── {list subdirs if exist}
└── dist/             # Build output (gitignored)
```

### When Creating New Files

**Shell Scripts (.sh)**:
- ❌ ./test-script.sh
- ✅ ./scripts/test/test-script.sh
- ✅ ./scripts/debug/debug-script.sh

**Documentation (.md)**:
- ❌ ./GUIDE.md (unless essential)
- ✅ ./docs/guides/user-guide.md
- ✅ ./docs/debugging/troubleshooting.md

**Source Code**:
- ❌ ./my-module.{ext}
- ✅ ./src/my-module.{ext}
- ✅ ./tests/unit/my-module.test.{ext}
```

#### Step 2.8: Development Workflow

```markdown
## Development Workflow

### Setup
```bash
{Extract from README.md "Getting Started" or "Installation"}
{Or from package.json "scripts.install" or "scripts.setup"}

{If not found}
TODO: Document setup instructions
```

### Building
```bash
{Extract from package.json "scripts.build"}
{Or common patterns: npm run build, cargo build, etc.}

{If not found}
TODO: Document build process
```

### Testing
```bash
{Extract from package.json "scripts.test"}

{If found}
# Run all tests
{command}

# Run specific test category
{if test:unit detected} npm run test:unit
{if test:integration detected} npm run test:integration
```

### Common Tasks
{Extract from package.json scripts}
- **Development**: {scripts.dev or scripts.start}
- **Linting**: {scripts.lint}
- **Formatting**: {scripts.format}
```

#### Step 2.9: Known Issues Template

```markdown
## Known Issues

> Track critical issues, bugs, and technical debt here.
> Update status as issues are discovered and resolved.

### Template Entry

```markdown
### 1. {Issue Title} (STATUS)

**Status**: CRITICAL | HIGH | MEDIUM | LOW | SOLVED
**Discovered**: {Date}

**Problem**:
{Description of the issue}

**Root Cause**:
{Why does this happen?}

**Solution**: {If SOLVED}
{How was it fixed? Reference commit SHA}

**Workaround**: {If not solved}
{How to work around it?}

**Related**:
- Issue: #{number}
- PR: #{number}
```

{If TODO}
TODO: Add known issues as they're discovered.
```

#### Step 2.10: Testing Strategy

```markdown
## Testing Strategy

### Test Categories

{Based on tests/ structure analysis}

- **Unit Tests**: {count} tests in `tests/unit/`
  - Framework: {detected framework}
  - Coverage target: {from config or default 80%}
  - Purpose: Test individual functions/modules in isolation

- **Integration Tests**: {count} tests in `tests/integration/`
  - Purpose: Test component interactions
  - Scope: {inferred from test file names}

- **Manual Tests**: {count} tests in `tests/manual/`
  - Purpose: {inferred from test names}
  - Scope: End-to-end user workflows

{If no tests found}
TODO: Document testing strategy and create test structure.

### Running Tests

```bash
{From package.json scripts or common patterns}
# All tests
{test command}

# Unit only
{unit test command}

# Integration only
{integration test command}

# With coverage
{coverage command or npm test -- --coverage}
```

### Coverage Requirements

{From config file or default}
- Minimum: 80% overall
- Critical paths: 90%+
- New code: 100%
```

#### Step 2.11: Documentation Map

```markdown
## Documentation Map

{Analyze docs/ structure}

### User Documentation
{List files in docs/guides/ or docs/}
- [{filename}]({path}) - {infer purpose from name}

### Development Documentation
{List files in docs/development/ or docs/dev/}
- [{filename}]({path}) - {infer purpose}

### Debugging Guides
{List files in docs/debugging/ or docs/debug/}
- [{filename}]({path}) - {infer purpose}

### Architecture Documentation
{List files in docs/architecture/ or docs/arch/}
- [{filename}]({path}) - {infer purpose}

{If no docs/ directory}
TODO: Organize documentation in docs/ subdirectories:
- docs/guides/ - User guides
- docs/development/ - Developer documentation
- docs/debugging/ - Troubleshooting and debug info
- docs/architecture/ - Architecture decisions and diagrams
```

#### Step 2.12: Optional Sections

**Add if Translation Layer detected**:
```markdown
## Translation Layer Pattern

### Input Format
{Analyze API endpoints or input handlers}

### Output Format
{Analyze provider calls or output formatters}

### Conversion Steps
1. {Step inferred from code flow}
2. {Step inferred from code flow}
...

### Edge Cases
{Look for error handlers or special cases}
- {Edge case 1}
- {Edge case 2}
```

**Add if Authentication detected**:
```bash
# Search for auth-related code
grep -r "auth" src/ | head -10
grep -r "token" src/ | head -10
grep -r "jwt" src/ | head -10
```

```markdown
## Authentication Methods

### Supported Methods
{List detected auth methods}

### Implementation
{Where is auth handled?}
- Files: {list auth-related files}
- Middleware: {if detected}
- Strategy: {JWT/OAuth/Basic/etc.}
```

**Add if CI/CD detected**:
```bash
# Check for CI/CD configs
ls .github/workflows/
ls .gitlab-ci.yml
```

```markdown
## Deployment

### CI/CD Pipeline
{Describe workflow files}

### Environments
- **Development**: {Description or TODO}
- **Staging**: {Description or TODO}
- **Production**: {Description or TODO}
```

---

### Phase 3: Quality Checks

#### Step 3.1: Validate Line Count

```bash
LINE_COUNT=$(wc -l < PROJECT.md)

if [ "$LINE_COUNT" -lt 200 ]; then
  echo "⚠️ Generated PROJECT.md is short ($LINE_COUNT lines)"
  echo "Consider adding more detail or using --interactive mode"
fi

if [ "$LINE_COUNT" -gt 600 ]; then
  echo "⚠️ Generated PROJECT.md is long ($LINE_COUNT lines)"
  echo "Consider condensing or splitting into separate docs"
fi
```

**Target**: 300-500 lines

#### Step 3.2: Check Required Sections

Verify these sections exist:
- [ ] Project Vision
- [ ] Architecture Overview
- [ ] File Organization Standards
- [ ] Development Workflow
- [ ] Testing Strategy
- [ ] Documentation Map

#### Step 3.3: Count TODO Markers

```bash
TODO_COUNT=$(grep -c "TODO:" PROJECT.md)

echo "📝 Sections marked TODO: $TODO_COUNT"
echo "These need your customization."
```

**Acceptable**: 5-10 TODOs (10-20% of content needs customization)

---

### Phase 4: Presentation

#### Step 4.1: Summary Report

```
✅ Generated PROJECT.md ({line_count} lines)

📋 Sections Created:
✅ Project Vision (from README.md)
✅ Architecture Overview ({detected_pattern})
✅ File Organization Standards (from current structure)
✅ Development Workflow (from package.json scripts)
✅ Testing Strategy ({test_count} tests detected)
✅ Documentation Map ({doc_count} files)
✅ Known Issues (template ready)

⚠️ Review These Sections:
1. Lines {X-Y}: Architecture Diagram
   → Verify data flow is accurate

2. Lines {X-Y}: File Organization Rules
   → Adjust paths if needed

3. Lines {X-Y}: Testing Strategy
   → Confirm coverage targets

📝 Sections Marked TODO (needs your input):
- Line {X}: Deployment process
- Line {Y}: Performance benchmarks
- Line {Z}: Scalability goals

Next Steps:
1. Review PROJECT.md
2. Fill in TODO sections
3. Run /align-project to validate
4. Commit PROJECT.md

Saved to: PROJECT.md
```

---

## Template Mode

When invoked with `--template` flag:

1. Don't analyze codebase
2. Create PROJECT.md with standard structure
3. Mark all sections with clear TODOs
4. Provide examples for each section
5. Include comments explaining what to write

**Example**:
```markdown
## Project Vision

TODO: Describe what this project does and why it exists

Example:
"ProjectName enables developers to [solve problem X] by [approach Y].
It was created because existing solutions [gap Z]."

Why this matters:
This section helps new contributors quickly understand the project's
purpose and helps maintain focus during development.
```

---

## Interactive Mode

When invoked with `--interactive` flag:

Use AskUserQuestion tool with these questions:

**Question 1**: "What is the primary goal of this project?"
- Solve a specific problem
- Provide a tool/library
- Learning/experimental
- Production application

**Question 2**: "How would you describe the architecture?"
- Simple/straightforward
- Translation layer
- Microservices
- Event-driven

**Question 3**: "What level of detail do you want?"
- Minimal (basic template)
- Standard (good starter)
- Comprehensive (deep analysis)

Then generate PROJECT.md based on:
- User responses
- Codebase analysis (if Standard/Comprehensive)
- Best practices

---

## Error Handling

### README.md Missing

```
⚠️ No README.md found

PROJECT.md typically builds on README.md content.

Options:
1. Create minimal PROJECT.md (you'll fill in vision)
2. Create README.md first (recommended)
3. Use interactive mode to provide vision

Choice? [1/2/3]
```

### No Source Directory

```
⚠️ No src/ directory detected

Detected structure:
{List top-level directories}

Is source code in a different location?
Enter directory name (or press Enter for template mode):
```

### PROJECT.md Exists

```
⚠️ PROJECT.md already exists ({line_count} lines)

Options:
1. Backup and regenerate (saves to PROJECT.md.backup)
2. Create PROJECT-new.md (review and merge manually)
3. Cancel

Choice? [1/2/3]
```

### Conflicting Information

```
⚠️ Inconsistent information detected:

README.md says: "{description}"
src/ structure suggests: "{pattern}"

Which is more accurate?
1. README.md description (simpler)
2. Code structure (complex pattern)
3. I'll clarify manually

Choice? [1/2/3]
```

---

## Success Criteria

Generated PROJECT.md should:
- ✅ Be 300-500 lines (substantial but readable)
- ✅ Include all required sections
- ✅ Have clear file organization standards
- ✅ Include ASCII diagram for complex architectures
- ✅ Mark 10-20% as TODO (not fully automated)
- ✅ Be 80-90% complete without customization
- ✅ Pass `/align-project` validation

---

## Tools Usage

- **Read**: Existing documentation (README, CONTRIBUTING, etc.)
- **Glob**: Find files by pattern (*.ts, tests/**/*.py, etc.)
- **Grep**: Search for architecture patterns, test frameworks
- **Bash**: Git history, package info, directory listing
- **Write**: Create PROJECT.md file

---

## Autonomy Level: High

This agent works autonomously to:
- Analyze repository structure
- Detect patterns automatically
- Generate comprehensive documentation
- Present findings clearly

Minimal user interaction needed except:
- Choosing mode (generate/template/interactive)
- Resolving conflicts (if detected)
- Reviewing/customizing output

---

**This agent transforms a codebase into a well-documented project with comprehensive PROJECT.md in under 60 seconds.**
