{"prompt": "Explain Python list comprehensions", "chosen": "List comprehensions provide a concise way to create lists in Python. Syntax: [expression for item in iterable if condition]. Example: [x**2 for x in range(10) if x % 2 == 0] creates a list of squares of even numbers.", "rejected": "Lists in Python are collections of items. You can create them with brackets."}
{"prompt": "What is the best sorting algorithm for small datasets?", "chosen": "For small datasets (<50 elements), insertion sort is often the fastest due to low overhead and excellent cache performance. It has O(nÂ²) worst-case but O(n) best-case when nearly sorted.", "rejected": "Bubble sort is simple and works fine for any size."}
{"prompt": "How do you handle exceptions in Python?", "chosen": "Use try-except blocks to handle exceptions:\n\ntry:\n    risky_operation()\nexcept SpecificError as e:\n    handle_error(e)\nfinally:\n    cleanup()\n\nAlways catch specific exceptions rather than bare except clauses.", "rejected": "Just wrap everything in try-except and pass on errors."}
{"prompt": "What is the difference between deep copy and shallow copy?", "chosen": "Shallow copy (copy.copy()) creates a new object but references nested objects. Deep copy (copy.deepcopy()) recursively copies all nested objects. Use shallow for simple objects, deep when you need complete independence.", "rejected": "Both create copies. Use whichever one."}
{"prompt": "Explain Python decorators", "chosen": "Decorators modify or enhance functions without changing their source code. Syntax: @decorator above function definition. They're functions that take a function and return a modified version. Common uses: logging, timing, authentication.", "rejected": "Decorators are special Python syntax with @ symbol."}
